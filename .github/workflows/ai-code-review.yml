name: AI Code Review with Gemini

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  ai-review:
    name: Gemini Code Review
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Install dependencies
        run: npm install @google/generative-ai

      - name: Get PR diff
        id: pr-diff
        env:
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          echo "base=$BASE_SHA" >> $GITHUB_OUTPUT
          echo "head=$HEAD_SHA" >> $GITHUB_OUTPUT

      - name: AI Review with Gemini
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          BASE_SHA: ${{ steps.pr-diff.outputs.base }}
          HEAD_SHA: ${{ steps.pr-diff.outputs.head }}
        run: |
          cat > review.js << 'EOFJS'
          const { GoogleGenerativeAI } = require('@google/generative-ai');
          const { execSync } = require('child_process');
          const fs = require('fs');

          async function reviewCode() {
            try {
              if (!process.env.GEMINI_API_KEY) {
                throw new Error('GEMINI_API_KEY not found. Please add it to GitHub Secrets.');
              }

              const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
              const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

              const baseSha = process.env.BASE_SHA;
              const headSha = process.env.HEAD_SHA;
              
              console.log(`Comparing ${baseSha}...${headSha}`);
              
              // Fetch base branch
              execSync(`git fetch origin ${baseSha}`, { stdio: 'inherit' });
              
              // Get changed files
              const changedFiles = execSync(`git diff --name-only ${baseSha}...${headSha}`)
                .toString()
                .trim()
                .split('\n')
                .filter(f => f && /\.(js|php|css|html)$/.test(f));

              if (changedFiles.length === 0) {
                console.log('No relevant files to review');
                fs.writeFileSync('review-output.md', '## ü§ñ Gemini Code Review\n\n‚úÖ Kh√¥ng c√≥ file JS/PHP/CSS/HTML n√†o thay ƒë·ªïi.\n');
                return;
              }

              console.log(`Found ${changedFiles.length} files to review:`);
              changedFiles.forEach(f => console.log(`  - ${f}`));

              let reviewComments = [];

              for (const file of changedFiles) {
                try {
                  console.log(`\nReviewing ${file}...`);
                  
                  const diff = execSync(`git diff ${baseSha}...${headSha} -- "${file}"`).toString();
                  
                  if (!diff.trim()) {
                    console.log(`  Skipped (no diff)`);
                    continue;
                  }

                  // Limit diff size
                  const diffPreview = diff.length > 4000 ? diff.substring(0, 4000) + '\n... (truncated)' : diff;

                  const prompt = `B·∫°n l√† senior developer review code.

          File: ${file}

          Diff:
          \`\`\`diff
          ${diffPreview}
          \`\`\`

          H√£y review code changes theo c√°c ti√™u ch√≠:
          1. üîí **Security** - SQL injection, XSS, CSRF, hardcoded credentials
          2. üêõ **Bugs** - Logic errors, null pointer, edge cases
          3. üí° **Code quality** - Clean code, naming, structure
          4. ‚ö° **Performance** - N+1 queries, memory leaks, slow operations
          5. üßπ **Maintainability** - Readability, complexity, documentation

          **Ch·ªâ comment n·∫øu c√≥ v·∫•n ƒë·ªÅ th·ª±c s·ª± quan tr·ªçng ho·∫∑c g·ª£i √Ω c·∫£i thi·ªán ƒë√°ng k·ªÉ.**
          N·∫øu code OK, ch·ªâ c·∫ßn n√≥i "‚úÖ Looks good!"

          Tr·∫£ l·ªùi ng·∫Øn g·ªçn, c·ª• th·ªÉ, b·∫±ng ti·∫øng Vi·ªát. Format markdown.`;

                  const result = await model.generateContent(prompt);
                  const review = result.response.text();

                  reviewComments.push({ file, review });
                  console.log(`  ‚úÖ Reviewed successfully`);
                  
                  // Delay to avoid rate limit
                  await new Promise(resolve => setTimeout(resolve, 1000));

                } catch (error) {
                  console.error(`  ‚ùå Error: ${error.message}`);
                  reviewComments.push({
                    file,
                    review: `‚ö†Ô∏è Kh√¥ng th·ªÉ review: ${error.message}`
                  });
                }
              }

              // Generate review output
              let fullReview = `## ü§ñ Gemini Code Review\n\n`;
              fullReview += `**Model:** gemini-2.5-flash (FREE)\n`;
              fullReview += `**Files reviewed:** ${changedFiles.length}\n`;
              fullReview += `**Date:** ${new Date().toISOString()}\n\n`;
              fullReview += `---\n\n`;

              if (reviewComments.length === 0) {
                fullReview += `‚úÖ **Kh√¥ng c√≥ v·∫•n ƒë·ªÅ n√†o ƒë∆∞·ª£c ph√°t hi·ªán!**\n`;
              } else {
                reviewComments.forEach(({ file, review }) => {
                  fullReview += `### üìÑ \`${file}\`\n\n${review}\n\n---\n\n`;
                });
              }

              fullReview += `\n*ü§ñ Review t·ª± ƒë·ªông b·ªüi Gemini AI - Vui l√≤ng ki·ªÉm tra k·ªπ tr∆∞·ªõc khi merge!*\n`;

              fs.writeFileSync('review-output.md', fullReview);
              console.log('\n‚úÖ Review completed successfully!');

            } catch (error) {
              console.error('Fatal error:', error);
              const errorMsg = `## ü§ñ Gemini Code Review\n\n‚ùå **L·ªói:** ${error.message}\n\n`;
              const helpMsg = error.message.includes('GEMINI_API_KEY') 
                ? `### üîß C√°ch fix:\n1. V√†o https://aistudio.google.com/apikey\n2. T·∫°o API key (mi·ªÖn ph√≠)\n3. Th√™m v√†o GitHub: Settings ‚Üí Secrets ‚Üí Actions ‚Üí New secret\n   - Name: \`GEMINI_API_KEY\`\n   - Value: <your-api-key>\n`
                : `### üí° Suggestions:\n- Ki·ªÉm tra logs ·ªü tr√™n ƒë·ªÉ xem chi ti·∫øt\n- API key c√≥ th·ªÉ ƒë√£ h·∫øt quota\n- Network issue\n`;
              
              fs.writeFileSync('review-output.md', errorMsg + helpMsg);
              process.exit(0); // Don't fail the workflow
            }
          }

          reviewCode();
          EOFJS

          node review.js

      - name: Comment PR with Review
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            let reviewBody = '## ü§ñ Gemini Code Review\n\n‚ö†Ô∏è Kh√¥ng th·ªÉ load review. Ki·ªÉm tra logs.\n';

            try {
              if (fs.existsSync('review-output.md')) {
                reviewBody = fs.readFileSync('review-output.md', 'utf8');
              }
            } catch (error) {
              console.error('Error reading review:', error);
            }

            // Delete old bot comments
            try {
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });

              for (const comment of comments) {
                if (comment.user.type === 'Bot' && comment.body.includes('Gemini Code Review')) {
                  await github.rest.issues.deleteComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: comment.id,
                  });
                  console.log(`Deleted old comment ${comment.id}`);
                }
              }
            } catch (error) {
              console.error('Error managing comments:', error);
            }

            // Post new review
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: reviewBody
            });

            console.log('Posted review comment');
